/*
 * MM JDBC Drivers for MySQL
 *
 * $Id: ResultSet.java,v 1.2 2000/05/28 18:50:39 mmatthew Exp $
 *
 * Copyright (C) 1998 Mark Matthews <mmatthew@worldserver.com>
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330
 * Boston, MA  02111-1307, USA.
 *
 * See the COPYING file located in the top-level-directory of
 * the archive of this library for complete text of license.
 *
 * Some portions:
 *
 * Copyright (c) 1996 Bradley McLean / Jeffrey Medeiros
 * Modifications Copyright (c) 1996/1997 Martin Rode
 * Copyright (c) 1997 Peter T Mount
 */

/**
 * A ResultSet provides access to a table of data generated by executing a
 * Statement.  The table rows are retrieved in sequence.  Within a row its
 * column values can be accessed in any order.
 *
 * <P>A ResultSet maintains a cursor pointing to its current row of data.
 * Initially the cursor is positioned before the first row.  The 'next'
 * method moves the cursor to the next row.
 *
 * <P>The getXXX methods retrieve column values for the current row.  You can
 * retrieve values either using the index number of the column, or by using
 * the name of the column.  In general using the column index will be more
 * efficient.  Columns are numbered from 1.
 *
 * <P>For maximum portability, ResultSet columns within each row should be read
 * in left-to-right order and each column should be read only once.
 *
 *<P> For the getXXX methods, the JDBC driver attempts to convert the
 * underlying data to the specified Java type and returns a suitable Java
 * value.  See the JDBC specification for allowable mappings from SQL types
 * to Java types with the ResultSet getXXX methods.
 *
 * <P>Column names used as input to getXXX methods are case insenstive.  When
 * performing a getXXX using a column name, if several columns have the same
 * name, then the value of the first matching column will be returned.  The
 * column name option is designed to be used when column names are used in the
 * SQL Query.  For columns that are NOT explicitly named in the query, it is
 * best to use column numbers.  If column names were used there is no way for
 * the programmer to guarentee that they actually refer to the intended
 * columns.
 *
 * <P>A ResultSet is automatically closed by the Statement that generated it
 * when that Statement is closed, re-executed, or is used to retrieve the
 * next result from a sequence of multiple results.
 *
 * <P>The number, types and properties of a ResultSet's columns are provided by
 * the ResultSetMetaData object returned by the getMetaData method.
 *
 * @see ResultSetMetaData
 * @see java.sql.ResultSet
 * @author Mark Matthews <mmatthew@worldserver.com>
 * @version $Id: ResultSet.java,v 1.2 2000/05/28 18:50:39 mmatthew Exp $
 */

package org.gjt.mm.mysql.jdbc2;

import java.io.*;
import java.math.*;
import java.text.*;
import java.util.*;
import java.sql.*;

public class ResultSet extends org.gjt.mm.mysql.ResultSet 
    implements java.sql.ResultSet
{
    /**
     * SQL for in-place modifcation
     */

    protected String _UpdateSQL = null;

    protected String _DeleteSQL = null;

    protected String _InsertSQL = null;

    /**
     * PreparedStatement used to delete data
     */

    protected org.gjt.mm.mysql.jdbc2.PreparedStatement _Updater = null;

    /**
     * PreparedStatement used to insert data
     */

    protected org.gjt.mm.mysql.jdbc2.PreparedStatement _Inserter = null;

    /**
     * PreparedStatement used to delete data
     */

    protected org.gjt.mm.mysql.jdbc2.PreparedStatement _Deleter = null;

    /**
     * List of primary keys
     */

    protected Vector _PrimaryKeyIndicies = null;

    /**
     * Is this result set updateable?
     */

    protected boolean _updatable = false;

    /**
     * Are we in the middle of doing updates to the current row?
     */

    protected boolean _doing_updates = false;

    /**
     * Are we on the insert row?
     */

    protected boolean _on_insert_row = false;

    /**
     * The numbers, types and properties of a ResultSet's columns are
     * provided by the getMetaData method
     *
     * @return a description of the ResultSet's columns
     * @exception java.sql.SQLException if a database access error occurs
     */
  
    public java.sql.ResultSetMetaData getMetaData() throws java.sql.SQLException
    {
	return new org.gjt.mm.mysql.jdbc2.ResultSetMetaData(Rows, Fields);
    }

    //--------------------------JDBC 2.0-----------------------------------

    //---------------------------------------------------------------------
    // Getter's and Setter's
    //---------------------------------------------------------------------

    /**
     * JDBC 2.0
     *
     * <p>Get the value of a column in the current row as a java.io.Reader.
     */

    public java.io.Reader getCharacterStream(int columnIndex) 
	throws SQLException
    {
	throw new NotImplemented();
    }

    /**
     * JDBC 2.0
     *
     * <p>Get the value of a column in the current row as a java.io.Reader.
     */

    public java.io.Reader getCharacterStream(String columnName) 
	throws SQLException
    {
	throw new NotImplemented();
    }


    /**
     * JDBC 2.0
     *
     * Get the value of a column in the current row as a java.math.BigDecimal 
     * object.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @return the column value (full precision); if the value is SQL NULL, 
     * the result is null
     * @exception SQLException if a database-access error occurs.
     */

    public BigDecimal getBigDecimal(int columnIndex) throws SQLException
    {
	String S = getString(columnIndex);
	
        BigDecimal Val;

	if (S != null) {
	    if (S.length() == 0) {
		Val = new BigDecimal(0);
		return Val;
	    }
	    try {
		Val = new BigDecimal(S);
                
                return Val;
	    } 
	    catch (NumberFormatException E) {
		throw new java.sql.SQLException ("Bad format for BigDecimal '" + S + "' in column " + columnIndex + "(" + Fields[columnIndex - 1] + ").", "S1009");
	    }
	}
        
	return null;                // SQL NULL
    }

    /**
     * JDBC 2.0
     *
     * Get the value of a column in the current row as a java.math.BigDecimal 
     * object.
     *
     */
    
    public BigDecimal getBigDecimal(String columnName) throws SQLException
    {
	String S = getString(columnName);
	
        BigDecimal Val;

	if (S != null) {
	    if (S.length() == 0) {
		Val = new BigDecimal(0);
		return Val;
	    }
	    try {
		Val = new BigDecimal(S);
                
                return Val;
	    } 
	    catch (NumberFormatException E) {
		throw new java.sql.SQLException ("Bad format for BigDecimal '" + S + "' in column " + columnName + ".", "S1009");
	    }
	}
        
	return null;                // SQL NULL
    }

    //---------------------------------------------------------------------
    // Traversal/Positioning
    //---------------------------------------------------------------------

    /**
     * JDBC 1.0, over-ridden to handle row-updates
     */
    
    public boolean next() throws SQLException
    {
	if (_on_insert_row) {
	    _on_insert_row = false;
	}

	if (_doing_updates) {
	    _doing_updates = false;
	}

	return super.next();
    }

    /**
     * JDBC 2.0
     *
     * <p>Determine if the cursor is before the first row in the result 
     * set.   
     *
     * @return true if before the first row, false otherwise. Returns
     * false when the result set contains no rows.
     * @exception SQLException if a database-access error occurs.
     */

    public boolean isBeforeFirst() throws SQLException
    {
	if (Rows.size() == 0) {
	    return false;
	}
	else {
	    return (currentRow == -1);
	}
    }
 
      
    /**
     * JDBC 2.0
     *
     * <p>Determine if the cursor is after the last row in the result 
     * set.   
     *
     * @return true if after the last row, false otherwise.  Returns
     * false when the result set contains no rows.
     * @exception SQLException if a database-access error occurs.
     */

    public synchronized boolean isAfterLast() throws SQLException
    {
	if (Rows.size() == 0) {
	    return false;
	}
	else {
	    return (currentRow == Rows.size());
	}
    }
 
    /**
     * JDBC 2.0
     *
     * <p>Determine if the cursor is on the first row of the result set.   
     *
     * @return true if on the first row, false otherwise.   
     * @exception SQLException if a database-access error occurs.
     */

    public synchronized boolean isFirst() throws SQLException
    {
	if (Rows.size() == 0) {
	    return false;
	}
	else {
	    return (currentRow == 0);
	}
    }
 
    /**
     * JDBC 2.0
     *
     * <p>Determine if the cursor is on the last row of the result set.   
     * Note: Calling isLast() may be expensive since the JDBC driver
     * might need to fetch ahead one row in order to determine 
     * whether the current row is the last row in the result set.
     *
     * @return true if on the last row, false otherwise. 
     * @exception SQLException if a database-access error occurs.
     */

    public synchronized boolean isLast() throws SQLException
    {
	if (Rows.size() == 0) {
	    return false;
	}
	else {
	    return (currentRow == Rows.size() - 1);
	}
    }

    /**
     * JDBC 2.0
     *
     * <p>Moves to the front of the result set, just before the
     * first row. Has no effect if the result set contains no rows.
     *
     * @exception SQLException if a database-access error occurs, or
     * result set type is TYPE_FORWARD_ONLY
     */

    public synchronized void beforeFirst() throws SQLException
    {
	if (_on_insert_row) {
	    _on_insert_row = false;
	}

	if (_doing_updates) {
	    _doing_updates = false;
	}

	if (Rows.size() == 0) {
	    return;
	}
	else {
	    currentRow = -1;
	    This_Row = null;
	}
    }

    /**
     * JDBC 2.0
     *
     * <p>Moves to the end of the result set, just after the last
     * row.  Has no effect if the result set contains no rows.
     *
     * @exception SQLException if a database-access error occurs, or
     * result set type is TYPE_FORWARD_ONLY.
     */

    public void afterLast() throws SQLException
    {
	if (_on_insert_row) {
	    _on_insert_row = false;
	}

	if (_doing_updates) {
	    _doing_updates = false;
	}

	if (Rows.size() != 0) {
	    currentRow = Rows.size();
	    This_Row = null;
	}
    }

    /**
     * JDBC 2.0
     *
     * <p>Moves to the first row in the result set.  
     *
     * @return true if on a valid row, false if no rows in the result set.
     * @exception SQLException if a database-access error occurs, or
     * result set type is TYPE_FORWARD_ONLY.
     */

    public synchronized boolean first() throws SQLException
    {
	if (_on_insert_row) {
	    _on_insert_row = false;
	}

	if (Rows.size() == 0) {
	    return false;
	}
	else {
	    if (_doing_updates) {
		_doing_updates = false;
	    }
	    
	    currentRow = 0;
	    This_Row = (byte[][])Rows.elementAt(currentRow);

	    return true;
	}
    }

    /**
     * JDBC 2.0
     *
     * <p>Moves to the last row in the result set.  
     *
     * @return true if on a valid row, false if no rows in the result set.
     * @exception SQLException if a database-access error occurs, or
     * result set type is TYPE_FORWARD_ONLY.
     */

    public synchronized boolean last() throws SQLException
    {
	if (Rows.size() == 0) {
	    return false;
	}
	else {
	    if (_on_insert_row) {
		_on_insert_row = false;
	    }

	    if (_doing_updates) {
		_doing_updates = false;
	    }

	    currentRow = Rows.size() - 1;
	    This_Row = (byte[][])Rows.elementAt(currentRow);

	    return true;
	}
    }

    /**
     * JDBC 2.0
     *
     * <p>Determine the current row number.  The first row is number 1, the
     * second number 2, etc.  
     *
     * @return the current row number, else return 0 if there is no 
     * current row
     * @exception SQLException if a database-access error occurs.
     */

    public int getRow() throws SQLException
    {
        if (currentRow < 0 || 
	    currentRow > Rows.size() || 
	    Rows.size() == 0) {
	    return 0;
	}
	else {
	    return currentRow + 1;
	}
    }

    /**
     * JDBC 2.0
     *
     * <p>Move to an absolute row number in the result set.
     *
     * <p>If row is positive, moves to an absolute row with respect to the
     * beginning of the result set.  The first row is row 1, the second
     * is row 2, etc. 
     *
     * <p>If row is negative, moves to an absolute row position with respect to
     * the end of result set.  For example, calling absolute(-1) positions the 
     * cursor on the last row, absolute(-2) indicates the next-to-last
     * row, etc.
     *
     * <p>An attempt to position the cursor beyond the first/last row in
     * the result set, leaves the cursor before/after the first/last
     * row, respectively.
     *
     * <p>Note: Calling absolute(1) is the same as calling first().
     * Calling absolute(-1) is the same as calling last().
     *
     * @return true if on the result set, false if off.
     * @exception SQLException if a database-access error occurs, or 
     * row is 0, or result set type is TYPE_FORWARD_ONLY.
     */

    public synchronized boolean absolute(int row) throws SQLException
    {
	if (Rows.size() == 0) {
	    return false;
	}

	if (row == 0) {
	    throw new SQLException("Cannot absolute position to row 0", "S1009");
	}

	if (_on_insert_row) {
	    _on_insert_row = false;
	}

	if (_doing_updates) {
	    _doing_updates = false;
	}

	if (row == 1) {
	    return first();
	}
	else if (row == -1) {
	    return last();
	}

	if (row > Rows.size()) {
	    afterLast();
	    
	    return false;
	}
	else if (row < 0) {

	    // adjust to reflect after end of result set
	    int new_row_position = Rows.size() + row + 1;
	    
	    if (new_row_position <= 0) {
		beforeFirst();
		
		return false;
	    }
	    else {
		return absolute(new_row_position);
	    }
	}
	else {
	    row--; // adjust for index difference
	    currentRow = row;
	    This_Row = (byte[][])Rows.elementAt(currentRow);

	    return true;
	}
    }

    /**
     * JDBC 2.0
     *
     * <p>Moves a relative number of rows, either positive or negative.
     * Attempting to move beyond the first/last row in the
     * result set positions the cursor before/after the
     * the first/last row. Calling relative(0) is valid, but does
     * not change the cursor position.
     *
     * <p>Note: Calling relative(1) is different than calling next()
     * since is makes sense to call next() when there is no current row,
     * for example, when the cursor is positioned before the first row
     * or after the last row of the result set.
     *
     * @return true if on a row, false otherwise.
     * @exception SQLException if a database-access error occurs, or there
     * is no current row, or result set type is TYPE_FORWARD_ONLY.
     */

    public synchronized boolean relative(int rows) throws SQLException
    {
	if (Rows.size() == 0) {
	    return false;
	}

	int new_row_position = currentRow + rows + 1;

	return absolute(new_row_position);
    }

    /**
     * JDBC 2.0
     *
     * <p>Moves to the previous row in the result set.  
     *
     * <p>Note: previous() is not the same as relative(-1) since it
     * makes sense to call previous() when there is no current row.
     *
     * @return true if on a valid row, false if off the result set.
     * @exception SQLException if a database-access error occurs, or
     * result set type is TYPE_FORWAR_DONLY.
     */

    public boolean previous() throws SQLException
    {
	if (_on_insert_row) {
	    _on_insert_row = false;
	}

	if (_doing_updates) {
	    _doing_updates = false;
	}

	return prev();
    }

    protected int _fetch_direction = FETCH_FORWARD;

    /**
     * JDBC 2.0
     *
     * Give a hint as to the direction in which the rows in this result set
     * will be processed.  The initial value is determined by the statement
     * that produced the result set.  The fetch direction may be changed
     * at any time.
     *
     * @exception SQLException if a database-access error occurs, or
     * the result set type is TYPE_FORWARD_ONLY and direction is not 
     * FETCH_FORWARD.
     *
     * MM.MySQL actually ignores this, because it has the whole result
     * set anyway, so the direction is immaterial.
     */

    public void setFetchDirection(int direction) throws SQLException
    {
	if (direction != FETCH_FORWARD &&
	    direction != FETCH_REVERSE) {
	    throw new SQLException("Illegal value for fetch direction", "S1009");
	}
	else {
	    _fetch_direction = direction;
	}
    }

    /**
     * JDBC 2.0
     *
     * Return the fetch direction for this result set.
     *
     * @exception SQLException if a database-access error occurs 
     */

    public int getFetchDirection() throws SQLException
    {
	return _fetch_direction;
    }

    protected int _fetch_size = 0;

    /**
     * JDBC 2.0
     *
     * Give the JDBC driver a hint as to the number of rows that should 
     * be fetched from the database when more rows are needed for this result
     * set.  If the fetch size specified is zero, then the JDBC driver 
     * ignores the value, and is free to make its own best guess as to what
     * the fetch size should be.  The default value is set by the statement 
     * that creates the result set.  The fetch size may be changed at any 
     * time.
     *
     * @param rows the number of rows to fetch
     * @exception SQLException if a database-access error occurs, or the
     * condition 0 <= rows <= this.getMaxRows() is not satisfied.
     *
     * Currently ignored by this driver.
     */

    public void setFetchSize(int rows) throws SQLException
    {
	if (rows < 0 /* || rows > getMaxRows()*/) {
	    throw new SQLException("Value must be between 0 and getMaxRows()", "S1009");
	}

	_fetch_size = rows;
    }

    /**
     * JDBC 2.0
     *
     * Return the fetch size for this result set.
     *
     * @exception SQLException if a database-access error occurs 
     */

    public int getFetchSize() throws SQLException
    {
	return _fetch_size;
    }
  
    /**
     * JDBC 2.0
     *
     * Return the type of this result set.  The type is determined based
     * on the statement that created the result set.
     *
     * @return TYPE_FORWARD_ONLY, TYPE_SCROLL_INSENSITIVE, or
     * TYPE_SCROLL_SENSITIVE
     * @exception SQLException if a database-access error occurs
     */

    public int getType() throws SQLException
    {
	return TYPE_SCROLL_INSENSITIVE;
    }

    /**
     * JDBC 2.0
     *
     * Return the concurrency of this result set.  The concurrency
     * used is determined by the statement that created the result set.
     *
     * @return the concurrency type, CONCUR_READ_ONLY, etc.
     * @exception SQLException if a database-access error occurs
     */

    public int getConcurrency() throws SQLException
    {
	return (_updatable ? CONCUR_UPDATABLE : CONCUR_READ_ONLY);
    }

    //---------------------------------------------------------------------
    // Updates
    //---------------------------------------------------------------------

    /**
     * JDBC 2.0
     *
     * Determine if the current row has been updated.  The value returned 
     * depends on whether or not the result set can detect updates.
     *
     * @return true if the row has been visibly updated by the owner or
     * another, and updates are detected
     * @exception SQLException if a database-access error occurs
     * 
     * @see DatabaseMetaData#updatesAreDetected
     */

    public boolean rowUpdated() throws SQLException
    {
	throw new NotImplemented();
    }

    /**
     * JDBC 2.0
     *
     * Determine if the current row has been inserted.  The value returned 
     * depends on whether or not the result set can detect visible inserts.
     *
     * @return true if inserted and inserts are detected
     * @exception SQLException if a database-access error occurs
     * 
     * @see DatabaseMetaData#insertsAreDetected
     */

    public boolean rowInserted() throws SQLException
    {
	throw new NotImplemented();
    }
   
    /**
     * JDBC 2.0
     *
     * Determine if this row has been deleted.  A deleted row may leave
     * a visible "hole" in a result set.  This method can be used to
     * detect holes in a result set.  The value returned depends on whether 
     * or not the result set can detect deletions.
     *
     * @return true if deleted and deletes are detected
     * @exception SQLException if a database-access error occurs
     * 
     * @see DatabaseMetaData#deletesAreDetected
     */

    public boolean rowDeleted() throws SQLException
    {
	throw new NotImplemented();
    }

    /**
     * JDBC 2.0
     * 
     * Give a nullable column a null value.
     * 
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @exception SQLException if a database-access error occurs
     */

    public void updateNull(int columnIndex) throws SQLException
    {
	if (!_on_insert_row) {
	    if (!_doing_updates) {
		_doing_updates = true;
		
		syncUpdate();
	    }
	    
	    _Updater.setNull(columnIndex, 0);
	}
	else {
	    _Inserter.setNull(columnIndex, 0);
	}
    }

    /**
     * JDBC 2.0
     * 
     * Update a column with a boolean value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @exception SQLException if a database-access error occurs
     */
    
    public void updateBoolean(int columnIndex, boolean x) throws SQLException
    {
	if (!_on_insert_row) {
	    if (!_doing_updates) {
		_doing_updates = true;
		
		syncUpdate();
	    }
	    
	    _Updater.setBoolean(columnIndex, x);
	}
	else {
	    _Inserter.setBoolean(columnIndex, x);
	}
    }

    /**
     * JDBC 2.0
     *   
     * Update a column with a byte value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @exception SQLException if a database-access error occurs
     */

    public void updateByte(int columnIndex, byte x) throws SQLException
    {
	if (!_on_insert_row) {
	    if (!_doing_updates) {
		_doing_updates = true;
		
		syncUpdate();
	    }
	    
	    _Updater.setByte(columnIndex, x);
	}
	else {
	    _Inserter.setByte(columnIndex, x);
	}
    }

    /**
     * JDBC 2.0
     *   
     * Update a column with a short value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @exception SQLException if a database-access error occurs
     */

    public void updateShort(int columnIndex, short x) throws SQLException
    {	
	if (!_on_insert_row) {
	    if (!_doing_updates) {
		_doing_updates = true;
		
		syncUpdate();
	    }
	    
	    _Updater.setShort(columnIndex, x);
	}
	else {
	    _Inserter.setShort(columnIndex, x);
	}
    }

    /**
     * JDBC 2.0
     *   
     * Update a column with an integer value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @exception SQLException if a database-access error occurs
     */

    public void updateInt(int columnIndex, int x) throws SQLException
    {
	if (!_on_insert_row) {
	    if (!_doing_updates) {
		_doing_updates = true;
		
		syncUpdate();
	    }
	    
	    _Updater.setInt(columnIndex, x);
	}
	else {
	    _Inserter.setInt(columnIndex, x);
	}
    }

    /**
     * JDBC 2.0
     *   
     * Update a column with a long value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @exception SQLException if a database-access error occurs
     */

    public void updateLong(int columnIndex, long x) throws SQLException
    {
	if (!_on_insert_row) {
	    if (!_doing_updates) {
		_doing_updates = true;
		
		syncUpdate();
	    }
	    
	    _Updater.setLong(columnIndex, x);
	}
	else {
	    _Inserter.setLong(columnIndex, x);
	}
    }

    /**
     * JDBC 2.0
     *  
     * Update a column with a float value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @exception SQLException if a database-access error occurs
     */

    public void updateFloat(int columnIndex, float x) throws SQLException
    {	
	if (!_on_insert_row) {
	    if (!_doing_updates) {
		_doing_updates = true;
		
		syncUpdate();
	    }
	    
	    _Updater.setFloat(columnIndex, x);
	}
	else {
	    _Inserter.setFloat(columnIndex, x);
	}
    }

    /**
     * JDBC 2.0
     *  
     * Update a column with a Double value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @exception SQLException if a database-access error occurs
     */
    
    public void updateDouble(int columnIndex, double x) throws SQLException
    {	
	if (!_on_insert_row) {
	    if (!_doing_updates) {
		_doing_updates = true;
		
		syncUpdate();
	    }
	    
	    _Updater.setDouble(columnIndex, x);
	}
	else {
	    _Inserter.setDouble(columnIndex, x);
	}
    }

    /**
     * JDBC 2.0
     *  
     * Update a column with a BigDecimal value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @exception SQLException if a database-access error occurs
     */
    
    public void updateBigDecimal(int columnIndex, BigDecimal x) 
	throws SQLException
    {	
	if (!_on_insert_row) {
	    if (!_doing_updates) {
		_doing_updates = true;
		
		syncUpdate();
	    }
	    
	    _Updater.setBigDecimal(columnIndex, x);
	}
	else {
	    _Inserter.setBigDecimal(columnIndex, x);
	}
    }

    /**
     * JDBC 2.0
     *  
     * Update a column with a String value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @exception SQLException if a database-access error occurs
     */

    public void updateString(int columnIndex, String x) throws SQLException
    {	if (!_on_insert_row) {
	    if (!_doing_updates) {
		_doing_updates = true;
		
		syncUpdate();
	    }
	    
	    _Updater.setString(columnIndex, x);
	}
	else {
	    _Inserter.setString(columnIndex, x);
	}
    }

    /**
     * JDBC 2.0
     *  
     * Update a column with a byte array value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @exception SQLException if a database-access error occurs
     */
    
    public void updateBytes(int columnIndex, byte x[]) throws SQLException
    {	
	if (!_on_insert_row) {
	    if (!_doing_updates) {
		_doing_updates = true;
		
		syncUpdate();
	    }
	    
	    _Updater.setBytes(columnIndex, x);
	}
	else {
	    _Inserter.setBytes(columnIndex, x);
	}
    }

    /**
     * JDBC 2.0
     *  
     * Update a column with a Date value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @exception SQLException if a database-access error occurs
     */

    public void updateDate(int columnIndex, java.sql.Date x) throws SQLException
    {	
	if (!_on_insert_row) {
	    if (!_doing_updates) {
		_doing_updates = true;
		
		syncUpdate();
	    }
	    
	    _Updater.setDate(columnIndex, x);
	}
	else {
	    _Inserter.setDate(columnIndex, x);
	}
    }

    /**
     * JDBC 2.0
     *  
     * Update a column with a Time value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @exception SQLException if a database-access error occurs
     */

    public void updateTime(int columnIndex, java.sql.Time x) 
	throws SQLException
    {	
	if (!_on_insert_row) {
	    if (!_doing_updates) {
		_doing_updates = true;
		
		syncUpdate();
	    }
	    
	    _Updater.setTime(columnIndex, x);
	}
	else {
	    _Inserter.setTime(columnIndex, x);
	}
    }

    /**
     * JDBC 2.0
     *  
     * Update a column with a Timestamp value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @exception SQLException if a database-access error occurs
     */

    public void updateTimestamp(int columnIndex, java.sql.Timestamp x)
      throws SQLException
    {	
	if (!_on_insert_row) {
	    if (!_doing_updates) {
		_doing_updates = true;
		
		syncUpdate();
	    }
	    
	    _Updater.setTimestamp(columnIndex, x);
	}
	else {
	    _Inserter.setTimestamp(columnIndex, x);
	}
    }

    /** 
     * JDBC 2.0
     *  
     * Update a column with an ascii stream value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @param length the length of the stream
     * @exception SQLException if a database-access error occurs
     */

    public void updateAsciiStream(int columnIndex, 
				  java.io.InputStream x, 
				  int length) throws SQLException
    {
	if (!_on_insert_row) {
	    if (!_doing_updates) {
		_doing_updates = true;
		
		syncUpdate();
	    }
	    
	    _Updater.setAsciiStream(columnIndex, x, length);
	}
	else {
	    _Inserter.setAsciiStream(columnIndex, x, length);
	}
    }

    /** 
     * JDBC 2.0
     *  
     * Update a column with a binary stream value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value     
     * @param length the length of the stream
     * @exception SQLException if a database-access error occurs
     */
    
    public void updateBinaryStream(int columnIndex, 
				   java.io.InputStream x,
				   int length) throws SQLException
    {
	if (!_on_insert_row) {
	    if (!_doing_updates) {
		_doing_updates = true;
		
		syncUpdate();
	    }
	    
	    _Updater.setBinaryStream(columnIndex, x, length);
	}
	else {
	    _Inserter.setBinaryStream(columnIndex, x, length);
	}
    }

    /**
     * JDBC 2.0
     *  
     * Update a column with a character stream value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @param length the length of the stream
     * @exception SQLException if a database-access error occurs
     */

    public void updateCharacterStream(int columnIndex,
				      java.io.Reader x,
				      int length) throws SQLException
    {
	throw new NotImplemented();
    }

    /**
     * JDBC 2.0
     *  
     * Update a column with an Object value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @param scale For java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types
     *  this is the number of digits after the decimal.  For all other
     *  types this value will be ignored.
     * @exception SQLException if a database-access error occurs
     */

    public void updateObject(int columnIndex, Object x, int scale)
	throws SQLException
    {	
	if (!_on_insert_row) {
	    if (!_doing_updates) {
		_doing_updates = true;
		
		syncUpdate();
	    }
	    
	    _Updater.setObject(columnIndex, x);
	}
	else {
	    _Inserter.setObject(columnIndex, x);
	}
    }

    /**
     * JDBC 2.0
     *  
     * Update a column with an Object value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param x the new column value
     * @exception SQLException if a database-access error occurs
     */

    public void updateObject(int columnIndex, Object x) throws SQLException
    {	
	if (!_on_insert_row) {
	    if (!_doing_updates) {
		_doing_updates = true;
		
		syncUpdate();
	    }
	    
	    _Updater.setObject(columnIndex, x);
	}
	else {
	    _Inserter.setObject(columnIndex, x);
	}
    }

    /**
     * JDBC 2.0
     *  
     * Update a column with a null value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @exception SQLException if a database-access error occurs
     */

    public void updateNull(String columnName) throws SQLException
    {
	updateNull(findColumn(columnName));
    }

    /**
     * JDBC 2.0
     *  
     * Update a column with a boolean value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @exception SQLException if a database-access error occurs
     */
    
    public void updateBoolean(String columnName, boolean x) 
	throws SQLException
    {
	updateBoolean(findColumn(columnName), x);
    }

    /**
     * JDBC 2.0
     *  
     * Update a column with a byte value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @exception SQLException if a database-access error occurs
     */

    public void updateByte(String columnName, byte x) throws SQLException
    {
	updateByte(findColumn(columnName), x);
    }

    /**
     * JDBC 2.0
     *  
     * Update a column with a short value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @exception SQLException if a database-access error occurs
     */

    public void updateShort(String columnName, short x) throws SQLException
    {
	updateShort(findColumn(columnName), x);
    }

    /**
     * JDBC 2.0
     *  
     * Update a column with an integer value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @exception SQLException if a database-access error occurs
     */

    public void updateInt(String columnName, int x) throws SQLException
    {
	updateInt(findColumn(columnName), x);
    }

    /**
     * JDBC 2.0
     *  
     * Update a column with a long value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @exception SQLException if a database-access error occurs
     */

    public void updateLong(String columnName, long x) throws SQLException
    {
	updateLong(findColumn(columnName), x);
    }

    /**
     * JDBC 2.0
     *  
     * Update a column with a float value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @exception SQLException if a database-access error occurs
     */

    public void updateFloat(String columnName, float x) throws SQLException
    {
	updateFloat(findColumn(columnName), x);
    }

    /**
     * JDBC 2.0
     *  
     * Update a column with a double value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @exception SQLException if a database-access error occurs
     */

    public void updateDouble(String columnName, double x) throws SQLException
    {
	updateDouble(findColumn(columnName), x);
    }

    /**
     * JDBC 2.0
     *  
     * Update a column with a BigDecimal value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @exception SQLException if a database-access error occurs
     */

    public void updateBigDecimal(String columnName, BigDecimal x) 
	throws SQLException
    {
	updateBigDecimal(findColumn(columnName), x);
    }

    /**
     * JDBC 2.0
     *  
     * Update a column with a String value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @exception SQLException if a database-access error occurs
     */

    public void updateString(String columnName, String x) throws SQLException
    {
	updateString(findColumn(columnName), x);
    }

    /**
     * JDBC 2.0
     *  
     * Update a column with a byte array value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @exception SQLException if a database-access error occurs
     */

    public void updateBytes(String columnName, byte x[]) throws SQLException
    {
	updateBytes(findColumn(columnName), x);
    }

    /**
     * JDBC 2.0
     *  
     * Update a column with a Date value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @exception SQLException if a database-access error occurs
     */

    public void updateDate(String columnName, java.sql.Date x) 
	throws SQLException
    {
	updateDate(findColumn(columnName), x);
    }

    /**
     * JDBC 2.0
     *  
     * Update a column with a Time value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @exception SQLException if a database-access error occurs
     */

    public void updateTime(String columnName, java.sql.Time x) 
	throws SQLException
    {
	updateTime(findColumn(columnName), x);
    }

    /**
     * JDBC 2.0
     *  
     * Update a column with a Timestamp value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @exception SQLException if a database-access error occurs
     */

    public void updateTimestamp(String columnName, java.sql.Timestamp x)
      throws SQLException
    {
	updateTimestamp(findColumn(columnName), x);
    }

    /** 
     * JDBC 2.0
     *  
     * Update a column with an ascii stream value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @param length of the stream
     * @exception SQLException if a database-access error occurs
     */

    public void updateAsciiStream(String columnName, 
			   java.io.InputStream x, 
			   int length) throws SQLException
    {
	throw new NotImplemented();
    }

    /** 
     * JDBC 2.0
     *  
     * Update a column with a binary stream value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @param length of the stream
     * @exception SQLException if a database-access error occurs
     */

    public void updateBinaryStream(String columnName, 
				   java.io.InputStream x,
				   int length) throws SQLException
    {
	throw new NotImplemented();
    }

    /**
     * JDBC 2.0
     *  
     * Update a column with a character stream value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @param length of the stream
     * @exception SQLException if a database-access error occurs
     */

    public void updateCharacterStream(String columnName,
			     java.io.Reader reader,
			     int length) throws SQLException
    {
	throw new NotImplemented();
    }

    /**
     * JDBC 2.0
     *  
     * Update a column with an Object value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @param scale For java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types
     *  this is the number of digits after the decimal.  For all other
     *  types this value will be ignored.
     * @exception SQLException if a database-access error occurs
     */

    public void updateObject(String columnName, Object x, int scale)
	throws SQLException
    {
	updateObject(findColumn(columnName), x);
    }

    /**
     * JDBC 2.0
     *  
     * Update a column with an Object value.
     *
     * The updateXXX() methods are used to update column values in the
     * current row, or the insert row.  The updateXXX() methods do not 
     * update the underlying database, instead the updateRow() or insertRow()
     * methods are called to update the database.
     *
     * @param columnName the name of the column
     * @param x the new column value
     * @exception SQLException if a database-access error occurs
     */

    public void updateObject(String columnName, Object x) throws SQLException
    {
	updateObject(findColumn(columnName), x);
    }

    /**
     * JDBC 2.0
     *
     * Insert the contents of the insert row into the result set and
     * the database.  Must be on the insert row when this method is called.
     *
     * @exception SQLException if a database-access error occurs,
     * if called when not on the insert row, or if all non-nullable columns in
     * the insert row have not been given a value
     */

    public void insertRow() throws SQLException
    {
	if (!_on_insert_row) {
	    throw new SQLException("Not on insert row");
	}
	else {
	    _Inserter.executeUpdate();

	    int num_fields = Fields.length;

	    byte[][] NewRow = new byte[num_fields][];

	    for (int i = 0; i < num_fields; i++) {
		NewRow[i] = _Inserter.getBytes(i);
	    }

	    Rows.addElement(NewRow);

	    _Inserter.clearParameters();
	}
    }

    /**
     * JDBC 2.0
     *
     * Update the underlying database with the new contents of the
     * current row.  Cannot be called when on the insert row.
     *
     * @exception SQLException if a database-access error occurs, or
     * if called when on the insert row
     */

    public synchronized void updateRow() throws SQLException
    {
	if (_doing_updates) {
	    _Updater.executeUpdate();

	    int num_fields = Fields.length;

	    for (int i = 0; i < num_fields; i++) {
		This_Row[i] = _Updater.getBytes(i);
	    }

	    _doing_updates = false;
	}
    }
    

    /**
     * JDBC 2.0
     *
     * Delete the current row from the result set and the underlying
     * database.  Cannot be called when on the insert row.
     *
     * @exception SQLException if a database-access error occurs, or if
     * called when on the insert row.
     */

    public void deleteRow() throws SQLException
    {
	if (_on_insert_row) {
	    throw new SQLException("Can not call deleteRow() when on insert row");
	}
	
	if (Rows.size() == 0) {
	    throw new SQLException("Can't deleteRow() on empty result set");
	}

	if (_Deleter == null) {
	    if (_DeleteSQL == null) {
		generateStatements();
	    }

	    _Deleter = (org.gjt.mm.mysql.jdbc2.PreparedStatement)Conn.prepareStatement(_DeleteSQL);
	}

	_Deleter.clearParameters();
	
	String Encoding = null;
	
	if (Conn.useUnicode()) {
	    Encoding = Conn.getEncoding();
	}

	try {
	    int num_keys = _PrimaryKeyIndicies.size();
	    
	    if (num_keys == 1) {
		int index = ((Integer)_PrimaryKeyIndicies.elementAt(0)).intValue();
		String CurrentVal = (Encoding == null ? 
				     new String(This_Row[index]) : 
				     new String(This_Row[index], Encoding));
		_Deleter.setString(1, CurrentVal);
	    }
	    else {
		for (int i = 0; i < num_keys; i++) {
		    int index = ((Integer)_PrimaryKeyIndicies.elementAt(i)).intValue();
		    String CurrentVal = (Encoding == null ? 
					 new String(This_Row[index]) : 
					 new String(This_Row[index], Encoding));
		    _Deleter.setString(i + 1, CurrentVal);
		}
	    }

	    _Deleter.executeUpdate();

	    Rows.removeElementAt(currentRow);
	}
	catch (java.io.UnsupportedEncodingException UE) {
	    throw new SQLException("Unsupported character encoding '" + Conn.getEncoding() + "'");
	}

    }

    /**
     * JDBC 2.0
     *
     * Refresh the value of the current row with its current value in 
     * the database.  Cannot be called when on the insert row.
     *
     * The refreshRow() method provides a way for an application to 
     * explicitly tell the JDBC driver to refetch a row(s) from the
     * database.  An application may want to call refreshRow() when 
     * caching or prefetching is being done by the JDBC driver to
     * fetch the latest value of a row from the database.  The JDBC driver 
     * may actually refresh multiple rows at once if the fetch size is 
     * greater than one.
     * 
     * All values are refetched subject to the transaction isolation 
     * level and cursor sensitivity.  If refreshRow() is called after
     * calling updateXXX(), but before calling updateRow() then the
     * updates made to the row are lost.  Calling refreshRow() frequently
     * will likely slow performance.
     *
     * @exception SQLException if a database-access error occurs, or if
     * called when on the insert row.
     */

    public void refreshRow() throws SQLException
    {
	throw new NotImplemented();
    }

    /**
     * JDBC 2.0
     *
     * The cancelRowUpdates() method may be called after calling an
     * updateXXX() method(s) and before calling updateRow() to rollback 
     * the updates made to a row.  If no updates have been made or 
     * updateRow() has already been called, then this method has no 
     * effect.
     *
     * @exception SQLException if a database-access error occurs, or if
     * called when on the insert row.
     *
     */

    public void cancelRowUpdates () throws SQLException
    {
	if (_doing_updates) {
	    _doing_updates = false;

	    _Updater.clearParameters();
	}
    }

    /**
     * JDBC 2.0
     *
     * Move to the insert row.  The current cursor position is 
     * remembered while the cursor is positioned on the insert row.
     *
     * The insert row is a special row associated with an updatable
     * result set.  It is essentially a buffer where a new row may
     * be constructed by calling the updateXXX() methods prior to 
     * inserting the row into the result set.  
     *
     * Only the updateXXX(), getXXX(), and insertRow() methods may be 
     * called when the cursor is on the insert row.  All of the columns in 
     * a result set must be given a value each time this method is
     * called before calling insertRow().  UpdateXXX()must be called before
     * getXXX() on a column.
     *
     * @exception SQLException if a database-access error occurs,
     * or the result set is not updatable
     */

    public void moveToInsertRow() throws SQLException
    {
	if (_Inserter == null) {
	    generateStatements();

	    _Inserter = (org.gjt.mm.mysql.jdbc2.PreparedStatement)Conn.prepareStatement(_InsertSQL);
	}
	else {
	    _Inserter.clearParameters();
	}

	_on_insert_row = true;
	_doing_updates = false;
    }

    /**
     * JDBC 2.0
     *
     * Move the cursor to the remembered cursor position, usually the
     * current row.  Has no effect unless the cursor is on the insert 
     * row. 
     *
     * @exception SQLException if a database-access error occurs,
     * or the result set is not updatable
     */

    public void moveToCurrentRow() throws SQLException
    {
	if (!_updatable) {
	    throw new SQLException("ResultSet not updatable");
	}

	_on_insert_row = false;
    }

    /**
     * JDBC 2.0
     *
     * Return the Statement that produced the ResultSet.
     *
     * @return the Statment that produced the result set, or
     * null if the result was produced some other way.
     * @exception SQLException if a database-access error occurs
     */

    public java.sql.Statement getStatement() throws SQLException
    {
	throw new NotImplemented();
    }

    /**
     * JDBC 2.0
     *
     * Returns the value of column @i as a Java object.  Use the 
     * @map to determine the class from which to construct data of 
     * SQL structured and distinct types.
     *
     * @param i the first column is 1, the second is 2, ...
     * @param map the mapping from SQL type names to Java classes
     * @return an object representing the SQL value
     */

    public Object getObject(int i, java.util.Map map) throws SQLException
    {
	throw new NotImplemented();
    }

    /**
     * JDBC 2.0
     *
     * Get a REF(&lt;structured-type&gt;) column.
     *
     * @param i the first column is 1, the second is 2, ...
     * @return an object representing data of an SQL REF type
     */

    public java.sql.Ref getRef(int i) throws SQLException
    {
	throw new NotImplemented();
    }

    /**
     * JDBC 2.0
     *
     * Get a BLOB column.
     *
     * @param i the first column is 1, the second is 2, ...
     * @return an object representing a BLOB
     */

    public java.sql.Blob getBlob(int columnIndex) throws SQLException
    {
      if (columnIndex < 1 || columnIndex > Fields.length) {
        throw new java.sql.SQLException("Column Index out of range ( " + columnIndex + " > " + Fields.length + ").", "S1002");
      }
      
      return new Blob(This_Row[columnIndex - 1]);
    }

    /**
     * JDBC 2.0
     *
     * Get a CLOB column.
     *
     * @param i the first column is 1, the second is 2, ...
     * @return an object representing a CLOB
     */

    public java.sql.Clob getClob(int i) throws SQLException
    {
	throw new NotImplemented();
    }

    /**
     * JDBC 2.0
     *
     * Get an array column.
     *
     * @param i the first column is 1, the second is 2, ...
     * @return an object representing an SQL array
     */

    public java.sql.Array getArray(int i) throws SQLException
    {
	throw new NotImplemented();
    }

    /**
     * JDBC 2.0
     *
     * Returns the value of column @i as a Java object.  Use the 
     * @map to determine the class from which to construct data of 
     * SQL structured and distinct types.
     *
     * @param colName the column name
     * @param map the mapping from SQL type names to Java classes
     * @return an object representing the SQL value
     */

    public Object getObject(String colName, java.util.Map map) throws SQLException
    {
	throw new NotImplemented();
    }

    /**
     * JDBC 2.0
     *
     * Get a REF(&lt;structured-type&gt;) column.
     *
     * @param colName the column name
     * @return an object representing data of an SQL REF type
     */

    public java.sql.Ref getRef(String colName) throws SQLException
    {
	throw new NotImplemented();
    }

    /**
     * JDBC 2.0
     *
     * Get a BLOB column.
     *
     * @param colName the column name
     * @return an object representing a BLOB
     */

    public java.sql.Blob getBlob(String colName) throws SQLException
    {
	return getBlob(findColumn(colName));
    }

    /**
     * JDBC 2.0
     *
     * Get a CLOB column.
     *
     * @param colName the column name
     * @return an object representing a CLOB
     */

    public java.sql.Clob getClob(String colName) throws SQLException
    {
	throw new NotImplemented();
    }

    /**
     * JDBC 2.0
     *
     * Get an array column.
     *
     * @param colName the column name
     * @return an object representing an SQL array
     */
    
    public java.sql.Array getArray(String colName) throws SQLException
    {
	throw new NotImplemented();
    }

    /**
     * JDBC 2.0
     *
     * Get the value of a column in the current row as a java.sql.Date 
     * object.  Use the calendar to construct an appropriate millisecond
     * value for the Date, if the underlying database doesn't store
     * timezone information.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param cal the calendar to use in constructing the date
     * @return the column value; if the value is SQL NULL, the result is null
     * @exception SQLException if a database-access error occurs.
     */

    public java.sql.Date getDate(int columnIndex, Calendar cal) throws SQLException
    {
	throw new NotImplemented();
    }

    /**
     * Get the value of a column in the current row as a java.sql.Date 
     * object. Use the calendar to construct an appropriate millisecond
     * value for the Date, if the underlying database doesn't store
     * timezone information.
     *
     * @param columnName is the SQL name of the column
     * @param cal the calendar to use in constructing the date
     * @return the column value; if the value is SQL NULL, the result is null
     * @exception SQLException if a database-access error occurs.
     */

    public java.sql.Date getDate(String columnName, Calendar cal) throws SQLException
    {
	throw new NotImplemented();
    }

    /**
     * Get the value of a column in the current row as a java.sql.Time 
     * object. Use the calendar to construct an appropriate millisecond
     * value for the Time, if the underlying database doesn't store
     * timezone information.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param cal the calendar to use in constructing the time
     * @return the column value; if the value is SQL NULL, the result is null
     * @exception SQLException if a database-access error occurs.
     */

    public java.sql.Time getTime(int columnIndex, Calendar cal) throws SQLException
    {
	throw new NotImplemented();
    }

    /**
     * Get the value of a column in the current row as a java.sql.Time 
     * object. Use the calendar to construct an appropriate millisecond
     * value for the Time, if the underlying database doesn't store
     * timezone information.
     *
     * @param columnName is the SQL name of the column
     * @param cal the calendar to use in constructing the time
     * @return the column value; if the value is SQL NULL, the result is null
     * @exception SQLException if a database-access error occurs.
     */

    public java.sql.Time getTime(String columnName, Calendar cal) throws SQLException
    {
	throw new NotImplemented();
    }

    /**
     * Get the value of a column in the current row as a java.sql.Timestamp 
     * object. Use the calendar to construct an appropriate millisecond
     * value for the Timestamp, if the underlying database doesn't store
     * timezone information.
     *
     * @param columnIndex the first column is 1, the second is 2, ...
     * @param cal the calendar to use in constructing the timestamp
     * @return the column value; if the value is SQL NULL, the result is null
     * @exception SQLException if a database-access error occurs.
     */
    
    public java.sql.Timestamp getTimestamp(int columnIndex, Calendar cal) 
      throws SQLException
    {
	throw new NotImplemented();
    }

    /**
     * Get the value of a column in the current row as a java.sql.Timestamp 
     * object. Use the calendar to construct an appropriate millisecond
     * value for the Timestamp, if the underlying database doesn't store
     * timezone information.
     *
     * @param columnName is the SQL name of the column
     * @param cal the calendar to use in constructing the timestamp
     * @return the column value; if the value is SQL NULL, the result is null
     * @exception SQLException if a database-access error occurs.
     */

    public java.sql.Timestamp getTimestamp(String columnName, Calendar cal)	
      throws SQLException
    {
	throw new NotImplemented();
    }
  
    // ****************************************************************
    //
    //                       END OF PUBLIC INTERFACE
    //
    // ****************************************************************

    /**
     * Create a new ResultSet - Note that we create ResultSets to
     * represent the results of everything.
     *
     * @param Fields an array of field data
     * @param Tuples Vector of the actual data
     */

    public ResultSet(org.gjt.mm.mysql.Field[] Fields, Vector Tuples, org.gjt.mm.mysql.Connection Conn)
    {
	super(Fields, Tuples, Conn);

	_updatable = isUpdateable();
    }
	
    public ResultSet(org.gjt.mm.mysql.Field[] Fields, Vector Tuples)
    { 
	super(Fields, Tuples);
    }

    /**
     * Create a result set for an executeUpdate statement.
     *
     * @param updateCount the number of rows affected by the update
     */

    public ResultSet(long updateCount, long updateID)
    {
	super(updateCount, updateID);
    }

    /**
     * Figure out whether or not this ResultSet is updateable,
     * and if so, generate the PreparedStatements to support updates.
     */

    protected void generateStatements() throws SQLException
    {	
	if (!_updatable) {
	    throw new SQLException("ResultSet not updatable");
	}

	String TableName = Fields[0].getTableName();    

	_PrimaryKeyIndicies = new Vector();
	
	StringBuffer FieldValues = new StringBuffer();
	StringBuffer KeyValues = new StringBuffer();
	StringBuffer ColumnNames = new StringBuffer();
	StringBuffer InsertPlaceHolders = new StringBuffer();
	
	boolean first_time = true;

	boolean keys_first_time = true;
	
	for (int i = 0; i < Fields.length; i++) {
	    if (Fields[i].isPrimaryKey()) {
		_PrimaryKeyIndicies.addElement(new Integer(i));

		if (!keys_first_time) {
		    KeyValues.append(" AND ");
		}
		else {
		    keys_first_time = false;
		}
		    
		KeyValues.append(Fields[i].getName() + "=?");
	    }
	    	    
	    if (first_time) {
		first_time = false;
		FieldValues.append("SET ");
	    }
	    else {
		FieldValues.append(",");
		ColumnNames.append(",");
		InsertPlaceHolders.append(",");
	    }
	    
	    InsertPlaceHolders.append("?");
	    ColumnNames.append(Fields[i].getName());
	    FieldValues.append(Fields[i].getName() + "=?");
	}
	
	_UpdateSQL = "UPDATE " + TableName + " " + FieldValues.toString() + " WHERE " + KeyValues.toString();
	
	_InsertSQL = "INSERT INTO " + TableName + " (" + ColumnNames.toString() + ") VALUES (" + InsertPlaceHolders.toString() + ")";
	
	_DeleteSQL = "DELETE FROM " + TableName + " WHERE " + KeyValues.toString();
    }
    
    /**
     * Reset UPDATE prepared statement to value in current row.
     * 
     * This_Row MUST point to current, valid row.
     */

    synchronized void syncUpdate() throws SQLException
    {
        
        if (_Updater == null) {
            if (_UpdateSQL == null) {
                generateStatements();
            }
            
            _Updater = (org.gjt.mm.mysql.jdbc2.PreparedStatement)Conn.prepareStatement(_UpdateSQL);
        }
        
        int num_fields = Fields.length;
        
        _Updater.clearParameters();
        
        for (int i = 0; i < num_fields; i++) {
            if (This_Row[i] != null) { 
                _Updater.setBytes(i + 1, This_Row[i]);
            }
            else {
                _Updater.setNull(i + 1, 0);
            }
        }
        
        int num_keys = _PrimaryKeyIndicies.size();
        
        if (num_keys == 1) {
            int index = ((Integer)_PrimaryKeyIndicies.elementAt(0)).intValue();
            
            _Updater.setBytes(num_fields + 1, This_Row[((Integer)_PrimaryKeyIndicies.elementAt(0)).intValue()]);
        }
        else {
            for (int i = 0; i < num_keys; i++) {
                byte[] currentVal = This_Row[((Integer)_PrimaryKeyIndicies.elementAt(i)).intValue()];
                
                if (currentVal != null) {
                    _Updater.setBytes(num_fields + i + 1, currentVal);
                }
                else {
                    _Updater.setNull(num_fields + i + 1, 0);
                }
            }
        }
    }
        
    /**
     * Is this ResultSet updateable?
     */

    boolean isUpdateable()
    {
	if (Fields.length > 0) {
	    String TableName = Fields[0].getTableName();

	    //
	    // References only one table?
	    //

	    for (int i = 1; i < Fields.length; i++) {
		if (TableName == null || 
		    !Fields[i].getTableName().equals(TableName)) {
		    return false;
		}
	    }

	    if (TableName == null || TableName.length() == 0) {
		return false;
	    }
	}
	else {
	    return false;
	}

	//
	// Contains the primary key?
	//
	
	boolean has_primary_key = false;

	for (int i = 0; i < Fields.length; i++) {
	    if (Fields[i].isPrimaryKey()) {
		has_primary_key = true;

		break;
	    }
	}

	if (!has_primary_key) {
	    return false;
	}
	
	return true;
    }
	    
    /**
     * Allows Statements to determine the type of result set they ended
     * up building.
     */

    int getResultSetType()
    {
	return 0;
    }
}
